name: CD

on:
  push:
    branches: [ "main" ]

jobs:
  deploy:
    runs-on: ubuntu-latest
    needs: []
    env:
      APP_NAME: ${{ vars.APP_NAME }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Deploy to Ubuntu server over SSH
        env:
          SSH_HOST: ${{ secrets.SSH_HOST }}
          SSH_USER: ${{ secrets.SSH_USER }}
          SSH_PORT: ${{ secrets.SSH_PORT }}
          SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
          # App / environment config (set these in GitHub Variables/Secrets)
          APP_ENV: ${{ vars.APP_ENV }}
          APP_URL_BASE: ${{ vars.APP_URL_BASE }}
          DB_CONNECTION: ${{ vars.DB_CONNECTION }}
          DB_HOST: ${{ vars.DB_HOST }}
          DB_PORT: ${{ vars.DB_PORT }}
          DB_DATABASE: ${{ vars.DB_DATABASE }}
          DB_USERNAME: ${{ vars.DB_USERNAME }}
          DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
        run: |
          set -x
          mkdir -p ~/.ssh
          echo "${SSH_PRIVATE_KEY}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa

          if [ -n "$SSH_PORT" ]; then
            PORT_ARG="-p $SSH_PORT"
          else
            PORT_ARG=""
          fi

          # Tambah host ke known_hosts; jangan gagal walau ssh-keyscan error,
          # supaya error utama terlihat di langkah ssh berikutnya
          ssh-keyscan -H "$SSH_HOST" >> ~/.ssh/known_hosts 2>/dev/null || true

          REMOTE_DIR="~/apps/deploy/$APP_NAME"
          RUN_DIR="~/apps/$APP_NAME"
          # APP_URL_BASE diharapkan HANYA berisi host (tanpa https:// dan tanpa path)
          # mis: server.burhanfs.my.id
          APP_URL="https://${APP_URL_BASE:-server.burhanfs.my.id}/$APP_NAME"

          # Pastikan folder deploy dan run di server sudah ada
          ssh $PORT_ARG "$SSH_USER@$SSH_HOST" "mkdir -p $REMOTE_DIR $RUN_DIR"

          # Sinkronkan kode dari runner ke server (tanpa perlu git pull di server)
          RSYNC_SSH_OPTS="-i ~/.ssh/id_rsa"
          if [ -n "$SSH_PORT" ]; then
            RSYNC_SSH_OPTS="$RSYNC_SSH_OPTS -p $SSH_PORT"
          fi

          # Sinkronkan kode, tapi jangan sentuh file .env di server
          rsync -az --delete --exclude='.env' -e "ssh $RSYNC_SSH_OPTS" ./ "$SSH_USER@$SSH_HOST:$REMOTE_DIR"

          ssh -vvv $PORT_ARG "$SSH_USER@$SSH_HOST" << EOF
          set -e
          # Set environment dasar di shell remote (untuk docker compose dan generator .env)
          APP_NAME="$APP_NAME"
          APP_ENV="$APP_ENV"
          APP_URL_BASE="$APP_URL_BASE"
          APP_URL="$APP_URL"
          ASSET_URL="$APP_URL"
          DB_CONNECTION="$DB_CONNECTION"
          DB_HOST="$DB_HOST"
          DB_PORT="$DB_PORT"
          DB_DATABASE="$DB_DATABASE"
          DB_USERNAME="$DB_USERNAME"
          DB_PASSWORD="$DB_PASSWORD"
          export APP_NAME
          export APP_ENV APP_URL_BASE APP_URL
          export DB_CONNECTION DB_HOST DB_PORT DB_DATABASE DB_USERNAME DB_PASSWORD

          # Generate .env di RUN_DIR berdasarkan nilai dari GitHub (overwrite setiap deploy)
          # APP_KEY sengaja tidak diset di sini supaya memakai hasil
          # php artisan key:generate yang dijalankan saat build image (Dockerfile).
          : > "$RUN_DIR/.env"
          {
            echo "APP_NAME=$APP_NAME"
            echo "APP_ENV=$APP_ENV"
            echo "APP_URL=$APP_URL"
            echo "APP_URL_BASE=$APP_URL_BASE"
            echo "ASSET_URL=$APP_URL"

            echo "LOG_CHANNEL=stack"
            echo "LOG_LEVEL=info"

            echo "DB_CONNECTION=$DB_CONNECTION"
            echo "DB_HOST=$DB_HOST"
            echo "DB_PORT=$DB_PORT"
            echo "DB_DATABASE=$DB_DATABASE"
            echo "DB_USERNAME=$DB_USERNAME"
            echo "DB_PASSWORD=$DB_PASSWORD"

            echo "SESSION_DRIVER=database"
            echo "QUEUE_CONNECTION=database"
            echo "CACHE_STORE=database"
          } >> "$RUN_DIR/.env"

          # Pastikan docker-compose.yml di RUN_DIR selalu berasal dari REMOTE_DIR (kode repo)
          cp "$REMOTE_DIR/docker-compose.yml" "$RUN_DIR/docker-compose.yml"
          cd "$RUN_DIR"
          ls

          # Jalankan docker compose dengan APP_NAME yang di-pass ke environment root via sudo
          sudo env "APP_NAME=$APP_NAME" docker compose build --no-cache
          sudo env "APP_NAME=$APP_NAME" docker compose up -d
          sudo docker image prune -f
          EOF
